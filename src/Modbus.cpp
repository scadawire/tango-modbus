/*----- PROTECTED REGION ID(Modbus.cpp) ENABLED START -----*/
static const char *RcsId = "$Id: Modbus.cpp,v 1.5 2012-11-07 08:56:13 pascal_verdier Exp $";
//=============================================================================
//
// file :        Modbus.cpp
//
// description : C++ source for the Modbus class and its commands.
//               The class is derived from Device. It represents the
//               CORBA servant object which will be accessed from the
//               network. All commands which can be executed on the
//               Modbus are implemented in this file.
//
// project :     Modbus
//
// This file is part of Tango device class.
// 
// Tango is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Tango is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Tango.  If not, see <http://www.gnu.org/licenses/>.
// 
// $Author: pascal_verdier $
//
// $Revision: 1.5 $
// $Date: 2012-11-07 08:56:13 $
//
// $HeadURL:  $
//
//=============================================================================
//                This file is generated by POGO
//        (Program Obviously used to Generate tango Object)
//=============================================================================


#include <tango.h>
#include <Modbus.h>
#include <ModbusClass.h>
#include <CacheThread.h>
#ifdef _TG_WINDOWS_
	#include <sys/types.h>
#include <sys/timeb.h>
#endif

/*----- PROTECTED REGION END -----*/	//	Modbus.cpp

/**
 *  Modbus class description:
 *    A Class to handle the modbus protocol over TCP/IP or Serial (RTU).
 */

//================================================================
//  The following table gives the correspondence
//  between command and method names.
//
//  Command name                   |  Method name
//================================================================
//  State                          |  Inherited (no method)
//  Status                         |  Inherited (no method)
//  ForceSingleCoil                |  force_single_coil
//  ReadCoilStatus                 |  read_coil_status
//  ReadInputStatus                |  read_input_status
//  ReadHoldingRegisters           |  read_holding_registers
//  ReadInputRegisters             |  read_input_registers
//  PresetSingleRegister           |  preset_single_register
//  ReadExceptionStatus            |  read_exception_status
//  FetchCommEventCtr              |  fetch_comm_event_ctr
//  ForceMultipleCoils             |  force_multiple_coils
//  ReadMultipleCoilsStatus        |  read_multiple_coils_status
//  PresetMultipleRegisters        |  preset_multiple_registers
//  MaskWriteRegister              |  mask_write_register
//  ReadWriteRegister              |  read_write_register
//  PresetSingleRegisterBroadcast  |  preset_single_register_broadcast
//================================================================

//================================================================
//  Attributes managed is:
//================================================================
//================================================================

namespace Modbus_ns
{
/*----- PROTECTED REGION ID(Modbus::namespace_starting) ENABLED START -----*/

//	static initializations

/*----- PROTECTED REGION END -----*/	//	Modbus::namespace_starting

//--------------------------------------------------------
/**
 *	Method      : Modbus::Modbus()
 *	Description : Constructors for a Tango device
 *                implementing the classModbus
 */
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, string &s)
 : Tango::Device_4Impl(cl, s.c_str())
{
	/*----- PROTECTED REGION ID(Modbus::constructor_1) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_1
}
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, const char *s)
 : Tango::Device_4Impl(cl, s)
{
	/*----- PROTECTED REGION ID(Modbus::constructor_2) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_2
}
//--------------------------------------------------------
Modbus::Modbus(Tango::DeviceClass *cl, const char *s, const char *d)
 : Tango::Device_4Impl(cl, s, d)
{
	/*----- PROTECTED REGION ID(Modbus::constructor_3) ENABLED START -----*/
	init_device();
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::constructor_3
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::delete_device()
 *	Description : will be called at device destruction or at init command
 */
//--------------------------------------------------------
void Modbus::delete_device()
{
	DEBUG_STREAM << "Modbus::delete_device() " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::delete_device) ENABLED START -----*/
	
	//	Delete device allocated objects
	//	Delete device's allocated object

	if (theThread != NULL)
	{
		{
			omni_mutex_lock sync(thCmdMutex);
			thCmd = SUICIDE;
		}

		void *ptr;
		theThread->join(&ptr);
	}

	for (unsigned long loop = 0;loop < cacheDef.size();loop++)
	{
		delete cacheDef[loop].data_block_mutex;
		if (cacheDef[loop].char_data_cache_ptr != NULL)
			delete cacheDef[loop].char_data_cache_ptr;
		if (cacheDef[loop].short_data_cache_ptr != NULL)
			delete cacheDef[loop].short_data_cache_ptr;
	}
	cacheDef.clear();

	if (modbusCore)
		delete modbusCore;

	/*----- PROTECTED REGION END -----*/	//	Modbus::delete_device
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::init_device()
 *	Description : will be called at device initialization.
 */
//--------------------------------------------------------
void Modbus::init_device()
{
	DEBUG_STREAM << "Modbus::init_device() create device " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::init_device_before) ENABLED START -----*/
	
	//	Initialization before get_device_property() call
	modbusCore = NULL;
	theThread = NULL;
	thId = -1;
	logFile = "";
	
	    //--------------------------------------------


	/*----- PROTECTED REGION END -----*/	//	Modbus::init_device_before
	

	//	Get the device properties from database
	get_device_property();
	

	/*----- PROTECTED REGION ID(Modbus::init_device) ENABLED START -----*/
	
	//	Initialize device
	
    // Check configuration
	
    if( get_protocol_number()==MBUS_TCP ) {
	
      if(iphost.length()==0) {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_init",
				       (const char *)"Iphost property must be defined for TCP protocol.",
				       (const char *)"Modbus::init_device");

      }
	
    } else {
	
      if(serialline.length()==0) {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_init",
				       (const char *)"Serialline property must be defined for RTU protocol.",
				       (const char *)"Modbus::init_device");

      }
	
    }

    // Create the modbus core object
    long error=0;
    modbusCore = new ModbusCore((char *)serialline.c_str(),
				get_protocol_number(),
				address,
				(char *)iphost.c_str(),
				socketConnectionSleep,
				tCPTimeout,
				logFile,
				&error);
	
    if(error) {
      char tmp[256];
      sprintf(tmp,"Failed to create the modbus object. Error code:%ld:",error);
      Tango::Except::throw_exception(
				     (const char *)"Modbus::error_init",
				     (const char *)tmp,
				     (const char *)"Modbus::init_device");
    }
	
    set_status(modbusCore->Status());
	
//
// If the CacheConfig property is defined, check its validity
//

	if (cacheConfig.empty() == false)
	{
		if ((cacheConfig.size() % 3) != 0)
		{
     		Tango::Except::throw_exception(
				     (const char *)"Modbus_WrongProperty",
				     (const char *)"The device CacheConfig property does not have a correct number of element. Must be a 3 multiple",
				     (const char *)"Modbus::init_device");
		}

		long cached_block_nb = cacheConfig.size() / 3;
		for (long i = 0;i < cached_block_nb;i++)
		{
			string cmd = cacheConfig[i * 3];
			transform(cmd.begin(),cmd.end(),cmd.begin(),::tolower);
			if ((cmd != "readholdingregisters") &&
				(cmd != "readinputstatus") &&
				(cmd != "readinutregisters") &&
				(cmd != "readmultiplecoilsstatus"))
			{
      			char tmp[256];
      			sprintf(tmp,"The command %s is not supported to cache data",cacheConfig[i * 3].c_str());

				Tango::Except::throw_exception(
					(const char *)"Modbus_WrongProperty",
					(const char *)tmp,
					(const char *)"Modbus::init_device");
			}

//
// Check address definition
//

			for (unsigned int j = 0;j < cacheConfig[(i * 3) + 1].size();j++)
			{
				if (isdigit(cacheConfig[(i * 3) + 1][j]) == 0)
				{
      				char tmp[256];
      				sprintf(tmp,"The string %s is not a valid address specification",cacheConfig[(i * 3) + 1].c_str());

					Tango::Except::throw_exception(
						(const char *)"Modbus_WrongProperty",
						(const char *)tmp,
						(const char *)"Modbus::init_device");
				}
			}
			short adr = (short)atoi(cacheConfig[(i * 3) + 1].c_str());

//
// Check data_nb definition
//

			for (unsigned int j = 0;j < cacheConfig[(i * 3) + 2].size();j++)
			{
				if (isdigit(cacheConfig[(i * 3) + 2][j]) == 0)
				{
      				char tmp[256];
      				sprintf(tmp,"The string %s is not a valid data number specification",cacheConfig[(i * 3) + 2].c_str());

					Tango::Except::throw_exception(
						(const char *)"Modbus_WrongProperty",
						(const char *)tmp,
						(const char *)"Modbus::init_device");
				}
			}
			short nb_data = (short)atoi(cacheConfig[(i * 3) + 2].c_str());

			CacheDataBlock cdb;
			cdb.cmd_name = cmd;
			cdb.in_args.length(2);
			cdb.in_args[0] = adr;
			cdb.in_args[1] = nb_data;
			cdb.err = false;
			cdb.nb_sec = 0;
			cdb.data_block_mutex = new omni_mutex;

			if (cmd == "readinputstatus")
			{
				cdb.char_data_cache_ptr = new char [nb_data];
				cdb.short_data_cache_ptr = NULL;
			}
			else
			{
				cdb.short_data_cache_ptr = new short [nb_data];
				cdb.char_data_cache_ptr = NULL;
			}
			
			cacheDef.push_back(cdb);
		}

//
// Compute threshold to decide that the acquisition thread is dead
// The (3 * 2) comes from the TCP connection algorithum which sometimes
// wait 2 times for 2 sec
//

		Tango::DevLong cacheSleep_sec = cacheSleep / 1000;
		if (cacheSleep_sec < 1)
			cacheSleep_sec = 1;
		maxDeltaTh = (3 * 2) + cacheSleep_sec * 3 + cacheDef.size() * tCPTimeout;

//
// Start thread
//

		thCmd = RUN;
		theThread = new CacheThread(cacheDef,thCmdMutex,&thCmd,cacheSleep,this);
		theThread->start();
		thId = theThread->id();
		
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::init_device
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::get_device_property()
 *	Description : Read database to initialize property data members.
 */
//--------------------------------------------------------
void Modbus::get_device_property()
{
	/*----- PROTECTED REGION ID(Modbus::get_device_property_before) ENABLED START -----*/
	
	//	Initialize property data members
	protocol = "RTU";
    address = 1;
    serialline = "";
    iphost = "";

	/*----- PROTECTED REGION END -----*/	//	Modbus::get_device_property_before


	//	Read device properties from database.
	Tango::DbData	dev_prop;
	dev_prop.push_back(Tango::DbDatum("Protocol"));
	dev_prop.push_back(Tango::DbDatum("Iphost"));
	dev_prop.push_back(Tango::DbDatum("Serialline"));
	dev_prop.push_back(Tango::DbDatum("Address"));
	dev_prop.push_back(Tango::DbDatum("CacheConfig"));
	dev_prop.push_back(Tango::DbDatum("CacheSleep"));
	dev_prop.push_back(Tango::DbDatum("SocketConnectionSleep"));
	dev_prop.push_back(Tango::DbDatum("TCPTimeout"));
	dev_prop.push_back(Tango::DbDatum("LogFile"));

	//	is there at least one property to be read ?
	if (dev_prop.size()>0)
	{
		//	Call database and extract values
		if (Tango::Util::instance()->_UseDb==true)
			get_db_device()->get_property(dev_prop);
	
		//	get instance on ModbusClass to get class property
		Tango::DbDatum	def_prop, cl_prop;
		ModbusClass	*ds_class =
			(static_cast<ModbusClass *>(get_device_class()));
		int	i = -1;

		//	Try to initialize Protocol from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  protocol;
		else {
			//	Try to initialize Protocol from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  protocol;
		}
		//	And try to extract Protocol value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  protocol;

		//	Try to initialize Iphost from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  iphost;
		else {
			//	Try to initialize Iphost from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  iphost;
		}
		//	And try to extract Iphost value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  iphost;

		//	Try to initialize Serialline from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  serialline;
		else {
			//	Try to initialize Serialline from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  serialline;
		}
		//	And try to extract Serialline value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  serialline;

		//	Try to initialize Address from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  address;
		else {
			//	Try to initialize Address from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  address;
		}
		//	And try to extract Address value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  address;

		//	Try to initialize CacheConfig from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  cacheConfig;
		else {
			//	Try to initialize CacheConfig from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  cacheConfig;
		}
		//	And try to extract CacheConfig value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  cacheConfig;

		//	Try to initialize CacheSleep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  cacheSleep;
		else {
			//	Try to initialize CacheSleep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  cacheSleep;
		}
		//	And try to extract CacheSleep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  cacheSleep;

		//	Try to initialize SocketConnectionSleep from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  socketConnectionSleep;
		else {
			//	Try to initialize SocketConnectionSleep from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  socketConnectionSleep;
		}
		//	And try to extract SocketConnectionSleep value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  socketConnectionSleep;

		//	Try to initialize TCPTimeout from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  tCPTimeout;
		else {
			//	Try to initialize TCPTimeout from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  tCPTimeout;
		}
		//	And try to extract TCPTimeout value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  tCPTimeout;

		//	Try to initialize LogFile from class property
		cl_prop = ds_class->get_class_property(dev_prop[++i].name);
		if (cl_prop.is_empty()==false)	cl_prop  >>  logFile;
		else {
			//	Try to initialize LogFile from default device value
			def_prop = ds_class->get_default_device_property(dev_prop[i].name);
			if (def_prop.is_empty()==false)	def_prop  >>  logFile;
		}
		//	And try to extract LogFile value from database
		if (dev_prop[i].is_empty()==false)	dev_prop[i]  >>  logFile;

	}

	/*----- PROTECTED REGION ID(Modbus::get_device_property_after) ENABLED START -----*/
	
	//	Check device property data members init
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::get_device_property_after
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::always_executed_hook()
 *	Description : method always executed before any command is executed
 */
//--------------------------------------------------------
void Modbus::always_executed_hook()
{
	INFO_STREAM << "Modbus::always_executed_hook()  " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::always_executed_hook) ENABLED START -----*/
	
	//	code always executed before all requests
	

	/*----- PROTECTED REGION END -----*/	//	Modbus::always_executed_hook
}

//--------------------------------------------------------
/**
 *	Method      : Modbus::read_attr_hardware()
 *	Description : Hardware acquisition for attributes
 */
//--------------------------------------------------------
void Modbus::read_attr_hardware(TANGO_UNUSED(vector<long> &attr_list))
{
	DEBUG_STREAM << "Modbus::read_attr_hardware(vector<long> &attr_list) entering... " << endl;
	/*----- PROTECTED REGION ID(Modbus::read_attr_hardware) ENABLED START -----*/
	
	//	Add your own code
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::read_attr_hardware
}


//--------------------------------------------------------
/**
 *	Method      : Modbus::add_dynamic_attributes()
 *	Description : Create the dynamic attributes if any
 *                for specified device.
 */
//--------------------------------------------------------
void Modbus::add_dynamic_attributes()
{
	/*----- PROTECTED REGION ID(Modbus::add_dynamic_attributes) ENABLED START -----*/
	
	//	Add your own code to create and add dynamic attributes if any
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::add_dynamic_attributes
}

//--------------------------------------------------------
/**
 *	Command ForceSingleCoil related method
 *	Description: Write single coil (digital I/O) state.
 *
 *	@param argin coil address, 0/1
 */
//--------------------------------------------------------
void Modbus::force_single_coil(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::ForceSingleCoil()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::force_single_coil) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short coil_address, coil_value;
    unsigned char query[5], response[5];

    check_argin(argin,2,"Modbus::force_single_coil");
    coil_address = (*argin)[0];
    coil_value = (*argin)[1];

    query[0] = FORCE_SINGLE_COIL;
    query[1] = coil_address >> 8;
    query[2] = coil_address & 0xff;
    if (coil_value)
      {
	query[3] = 0xff;
	query[4] = 0x00;
      }
    else
      {
	query[3] = 0x00;
	query[4] = 0x00;
      }

    if(modbusCore->SendGet(query,5,response,5,&error) != OK)
      {		
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::force_single_coil");
      }


    for (int i=0; i<5; i++)
      {
	if (query[i] != response[i])
	  {
            Tango::Except::throw_exception(
					   (const char *)"Modbus::error_write",
					   (const char *)"Failed to force single coil (response not equal to query).",
					   (const char *)"Modbus::force_single_coil");
		
	  }
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::force_single_coil
}
//--------------------------------------------------------
/**
 *	Command ReadCoilStatus related method
 *	Description: Read coil (digital I/O) status.
 *
 *	@param argin coil address
 *	@returns Coil status
 */
//--------------------------------------------------------
Tango::DevShort Modbus::read_coil_status(Tango::DevShort argin)
{
	Tango::DevShort argout;
	DEBUG_STREAM << "Modbus::ReadCoilStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_coil_status) ENABLED START -----*/

    //	Add your own code to control device here
    long	error;
    unsigned char query[5], response[1024];
			
    query[0] = READ_COIL_STATUS;
    query[1] = argin >> 8;
    query[2] = argin & 0xff;
    query[3] = 0;  // Read only one bit
    query[4] = 1;  

    if(modbusCore->SendGet(query,5,response,3,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_coil_status");
      }
	
    argout = (response[2]!=0)?1:0;

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_coil_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadInputStatus related method
 *	Description: Read discrete input status. Return one boolean per array element.
 *
 *	@param argin input address, no. of inputs
 *	@returns Input status.
 */
//--------------------------------------------------------
Tango::DevVarCharArray *Modbus::read_input_status(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarCharArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_status) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    argout  = new Tango::DevVarCharArray();
    DEBUG_STREAM << "Modbus::read_input_status(): entering... !" << endl;

    //	Add your own code to control device here
    long error;
    short input_address, no_inputs, no_bytes, byteidx;
    unsigned char bitmask, query[5], response[1024];
	
    check_argin(argin,2,"Modbus::read_input_status");
    input_address = (*argin)[0];
    no_inputs = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0)
	{
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readinputstatus",input_address,no_inputs);
	}

	if (data_block == -1)
	{
		omni_mutex_lock sync(this->ris_mutex);

    	query[0] = READ_INPUT_STATUS;
    	query[1] = input_address >> 8;
    	query[2] = input_address & 0xff;
    	query[3] = no_inputs >> 8;
    	query[4] = no_inputs & 0xff;

    	no_bytes = (no_inputs+7)/8;
    	if(modbusCore->SendGet(query,5,response,no_bytes+2,&error) != OK)
      	{
			Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_input_status");
		}
	
    	argout->length(no_inputs);
    	for(int i=0;i<no_inputs;i++)
		{
      		bitmask = (1 << (i%8));
      		byteidx = i/8 + 2;
      		(*argout)[i] = (response[byteidx] & bitmask)?1:0;
    	}
	}
	else
	{
		long start = input_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

//
// Check that the thread is still running
//

			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh)
			{
				throw_ex = true;
			}
			else
			{

//
// Get data or error code
//

				if (cacheDef[data_block].err == false)
				{
					argout->length(no_inputs);
					for (int i = 0;i < no_inputs;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				}
				else
				{
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true)
		{
			if (errs.length() == 0)
			{
				Tango::Except::throw_exception((const char *)"Modbus_ThNotRunning",
											   (const char *)"The thread acquiring data is not running any more",
											   (const char *)"Modbus::read_holding_registers");
			}
			else
				throw Tango::DevFailed(errs);
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadHoldingRegisters related method
 *	Description: Read multiple 16bits registers.
 *
 *	@param argin register address, no. of registers
 *	@returns Holding 16bits register.
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_holding_registers(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadHoldingRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_holding_registers) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    argout  = new Tango::DevVarShortArray();
    DEBUG_STREAM << "Modbus::read_holding_registers(): entering... !" << endl;
  
    //	Add your own code to control device here
    long error;
    short register_address, no_registers, no_bytes;
    unsigned char query[5], response[1024];
  
    check_argin(argin,2,"Modbus::read_holding_registers");
    register_address = (*argin)[0];
    no_registers = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0)
	{
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readholdingregisters",register_address,no_registers);
	}

	if (data_block == -1)
	{
		omni_mutex_lock sync(this->rhr_mutex);

    	query[0] = READ_HOLDING_REGISTERS;
    	query[1] = register_address >> 8;
    	query[2] = register_address & 0xff;
    	query[3] = no_registers >> 8;
    	query[4] = no_registers & 0xff;
    
    	no_bytes = no_registers*2;
    	if(modbusCore->SendGet(query,5,response,no_bytes+2,&error) != OK)
     	{
			Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_holding_registers");
		}
		argout->length(no_registers);
		for (int i=0; i < no_registers; i++)
			(*argout)[i] = (response[i*2+2] << 8) + response[i*2+3];
	}
	else
	{
		long start = register_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

//
// Check that the thread is still running
//

			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh)
			{
				throw_ex = true;
			}
			else
			{

//
// Get data or error code
//

				if (cacheDef[data_block].err == false)
				{
					argout->length(no_registers);
					for (int i = 0;i < no_registers;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				}
				else
				{
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true)
		{
			if (errs.length() == 0)
			{
				Tango::Except::throw_exception((const char *)"Modbus_ThNotRunning",
											   (const char *)"The thread acquiring data is not running any more",
											   (const char *)"Modbus::read_holding_registers");
			}
			else
				throw Tango::DevFailed(errs);
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_holding_registers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ReadInputRegisters related method
 *	Description: Read Multiple 16bits input registers.
 *
 *	@param argin register address, no. of registers
 *	@returns Input 16bits registers
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_input_registers(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadInputRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_input_registers) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    argout  = new Tango::DevVarShortArray();
    argout->length(1);
    (*argout)[0] = 0;
    DEBUG_STREAM << "Modbus::read_input_registers(): entering... !" << endl;

    //	Add your own code to control device here
    long error;
    short register_address, no_registers, no_bytes;
    unsigned char query[5], response[1024];
	
    check_argin(argin,2,"Modbus::read_input_registers");
    register_address = (*argin)[0];
    no_registers = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0)
	{
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readinputregisters",register_address,no_registers);
	}

	if (data_block == -1)
	{
		omni_mutex_lock sync(this->rir_mutex);

    	argout->length(no_registers);

    //---------------------------------------
    // A modbus response frame is limited to
    // 250 bytes.
    // Limiting the number of registers to
    // be read at 120 per call seems OK.

#define MAX_NB_REG 120

    //---------------------------------------

    	int index = 0;

    
    	do  // Do as many readouts as required.
      	{
			int nb_reg_to_get;  // The number of registers to be read at next call.
	
			if(no_registers > MAX_NB_REG)  // Check for limit.
	  			nb_reg_to_get = MAX_NB_REG;
			else
	  		nb_reg_to_get = no_registers;

#ifdef EBUG
			cout << "register_address = " << register_address << endl;
			cout << "nb_reg_to_get    = " << nb_reg_to_get << endl;
#endif

			query[0] = READ_INPUT_REGISTERS;
			query[1] = register_address >> 8;
			query[2] = register_address & 0xff;
			query[3] = nb_reg_to_get >> 8;
			query[4] = nb_reg_to_get & 0xff;
	
			no_bytes = nb_reg_to_get * 2;

			if(modbusCore->SendGet(query,5,response,no_bytes+2,&error) != OK)
	  		{
	  			delete argout; // Avoid memory leak !
	    		Tango::Except::throw_exception(
					   (const char *)"Modbus::error_read",
					   (const char *)modbusCore->GetErrorMessage(error),
					   (const char *)"Modbus::read_input_registers");
	  		}
	
			for (int i=0; i < nb_reg_to_get; i++, index++)  // Copy received data to argout
	  			(*argout)[index] = (response[i*2+2] << 8) + response[i*2+3];

			register_address += nb_reg_to_get; // Update address pointer.
			no_registers -= nb_reg_to_get;     // Update remaining data to be read.
      	}
    	while(no_registers > 0);  // Still some registers to be read?
	}
	else
	{
		long start = register_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;
		
#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

//
// Check that the thread is still running
//

			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh)
			{
				throw_ex = true;
			}
			else
			{

//
// Get data or error code
//

				if (cacheDef[data_block].err == false)
				{
					argout->length(no_registers);
					for (int i = 0;i < no_registers;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				}
				else
				{
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true)
		{
			delete argout; // Avoid memory leak !
			if (errs.length() == 0)
			{

				Tango::Except::throw_exception((const char *)"Modbus_ThNotRunning",
											   (const char *)"The thread acquiring data is not running any more",
											   (const char *)"Modbus::read_holding_registers");
			}
			else
				throw Tango::DevFailed(errs);
		}
	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_input_registers
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegister related method
 *	Description: Write single 16bits register.
 *
 *	@param argin Register address, register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short register_address, value;
    unsigned char query[5], response[1024];
	
    check_argin(argin,2,"Modbus::preset_single_register");
    register_address = (*argin)[0];
    value = (*argin)[1];
	
    query[0] = PRESET_SINGLE_REGISTER;
    query[1] = register_address >> 8;
    query[2] = register_address & 0xff;
    query[3] = value >> 8;
    query[4] = value & 0xff;

    if(modbusCore->SendGet(query,5,response,5,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::preset_single_register");
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register
}
//--------------------------------------------------------
/**
 *	Command ReadExceptionStatus related method
 *	Description: Read exception status (usually a predefined range of 8 bits
 *
 *	@returns exception status
 */
//--------------------------------------------------------
Tango::DevShort Modbus::read_exception_status()
{
	Tango::DevShort argout;
	DEBUG_STREAM << "Modbus::ReadExceptionStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_exception_status) ENABLED START -----*/
	
    //	Add your own code to control device here
    long error;
    unsigned char query[5], response[1024];
	
    query[0] = READ_EXCEPTION_STATUS;

    if(modbusCore->SendGet(query,1,response,2,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_exception_status");
      }

    argout = (short)response[0];

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_exception_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command FetchCommEventCtr related method
 *	Description: Fetch communications event counter.
 *
 *	@returns status, event count
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::fetch_comm_event_ctr()
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::FetchCommEventCtr()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::fetch_comm_event_ctr) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    argout  = new Tango::DevVarShortArray();
    long error;
    unsigned char query[5], response[1024];
	
    query[0] = FETCH_COMM_EVENT_CTR;

    if(modbusCore->SendGet(query,1,response,5,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::fetch_comm_event_ctr");
      }
	
    argout->length(2);
    (*argout)[0] = (response[0] << 8) + response[1];
    (*argout)[1] = (response[2] << 8) + response[3];

	/*----- PROTECTED REGION END -----*/	//	Modbus::fetch_comm_event_ctr
	return argout;
}
//--------------------------------------------------------
/**
 *	Command ForceMultipleCoils related method
 *	Description: Write multiple coils (digital I/O) state.
 *               argin[0] = coil_address
 *               argin[1] = number of coils
 *               argin[2] = 1st coil state
 *               argin[3] = 2nd coil state
 *               ...
 *
 *	@param argin coil address, nb of coils, coil states
 */
//--------------------------------------------------------
void Modbus::force_multiple_coils(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::ForceMultipleCoils()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::force_multiple_coils) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short coil_address, no_coils, no_bytes, byteidx;
    unsigned char bitmask, query[1024], response[1024];
	
    if(argin->length()<3) {
      Tango::Except::throw_exception(
				     (const char *)"Modbus::error_write",
				     (const char *)"At least 3 input arguments expected.",
				     (const char *)"Modbus::force_multiple_coils");	
    }

    coil_address = (*argin)[0];
    no_coils = (*argin)[1];
	
    check_argin(argin,2+no_coils,"Modbus::force_multiple_coils");

    memset(query,0,1024);
    query[0] = FORCE_MULTIPLE_COILS;
    query[1] = coil_address >> 8;
    query[2] = coil_address & 0xff;
    query[3] = no_coils >> 8;
    query[4] = no_coils & 0xff;
    query[5] = (no_coils+7)/8;
    for (int i=0; i<no_coils; i++)
      {
	bitmask = (1 << (i%8));
	byteidx = i/8 + 6;
	if((*argin)[2+i])
	  query[byteidx] |= bitmask;
      }
    no_bytes = 6+(no_coils+7)/8;

    if(modbusCore->SendGet(query,no_bytes,response,5,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::force_multiple_coils");
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::force_multiple_coils
}
//--------------------------------------------------------
/**
 *	Command ReadMultipleCoilsStatus related method
 *	Description: Read multiple coil (digital I/O) status.
 *               argin[0] = register address
 *               argin[1] = number of registers
 *
 *	@param argin coil address, nb of coils
 *	@returns Status of coils
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_multiple_coils_status(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadMultipleCoilsStatus()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_multiple_coils_status) ENABLED START -----*/

    //	Add your own code to control device here
    long error;
    short coil_address, no_coils;
    unsigned char query[1024], response[1024];
	
    if ( argin->length() != 2 ) 
     {
		Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)"2 input arguments required.",
				       (const char *)"Modbus::read_multiple_coils_status");	
     }

    argout  = new Tango::DevVarShortArray();		
    coil_address = (*argin)[0];
    no_coils     = (*argin)[1];

	int data_block = -1;
	omni_thread *th = omni_thread::self();
	if (th != 0)
	{
		int th_id = th->id();
		if (th_id != thId)
			data_block = data_in_cache("readmultiplecoilsstatus",coil_address,no_coils);
	}

	if (data_block == -1)
	{
		omni_mutex_lock sync(this->rmcs_mutex);

    	query[0] = READ_COIL_STATUS;
    	query[1] = coil_address >> 8;
    	query[2] = coil_address & 0xff;
    	query[3] = no_coils >> 8;
    	query[4] = no_coils & 0xff;


    	short no_bytes = (no_coils+7)/8;
    	DEBUG_STREAM << "no of bytes = " << no_bytes << endl;
	
    	if ( modbusCore->SendGet (query, 5, response, (no_bytes + 2), &error) != OK)
      	{
			Tango::Except::throw_exception(
				       (const char *)"Modbus::error_read",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_multiple_coils_status");
      	}

    	argout->length(no_coils);
	
	
    	for (int seq=0, idx=0 ; seq < no_bytes ; seq++)
      	{
			unsigned char word = response[seq + 2];
			for (int i=0 ; (i < 8)  && (idx < no_coils); i++)
	  		{
	    		DEBUG_STREAM << idx << ":	" << word << " & " << (1<<i) << " = " << (word & 1<<i) << endl;
	    		unsigned char bit_value = (word & (1<<i)) >> i;
			
	    		(*argout)[idx] = (bit_value != 0) ? 1:0;
	    		idx++;
	  		}
      	}
	}
	else
	{
		long start = coil_address - cacheDef[data_block].in_args[0];
		struct timeval when;
		Tango::DevErrorList errs;
		bool throw_ex = false;

#ifdef _TG_WINDOWS_
		struct _timeb now_win;
		_ftime(&now_win);
		when.tv_sec = (unsigned long)now_win.time;
		when.tv_usec = (long)now_win.millitm * 1000;
#else
		gettimeofday(&when,NULL);
#endif

		{
			omni_mutex_lock sync(*(cacheDef[data_block].data_block_mutex));

//
// Check that the thread is still running
//

			unsigned int th_sec = cacheDef[data_block].nb_sec;
			unsigned int delta_sec = when.tv_sec - th_sec;

			if (delta_sec > (unsigned int)maxDeltaTh)
			{
				throw_ex = true;
			}
			else
			{

//
// Get data or error code
//

				if (cacheDef[data_block].err == false)
				{
					argout->length(no_coils);
					for (int i = 0;i < no_coils;i++)
						(*argout)[i] = cacheDef[data_block].short_data_cache_ptr[start + i];
				}
				else
				{
					errs = cacheDef[data_block].errors;
					throw_ex = true;
				}
			}
		}

		if (throw_ex == true)
		{
			if (errs.length() == 0)
			{
				Tango::Except::throw_exception((const char *)"Modbus_ThNotRunning",
											   (const char *)"The thread acquiring data is not running any more",
											   (const char *)"Modbus::read_holding_registers");
			}
			else
				throw Tango::DevFailed(errs);
		}

	}

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_multiple_coils_status
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetMultipleRegisters related method
 *	Description: Write multiple 16bits registers.
 *               argin[0] = register address
 *               argin[1] = number of registers
 *               argin[2] = 1st register
 *               argin[3] = 2nd register
 *               ...
 *
 *	@param argin register address, nb of registers, register data
 */
//--------------------------------------------------------
void Modbus::preset_multiple_registers(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetMultipleRegisters()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_multiple_registers) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short register_address, no_registers, no_bytes;
    unsigned char query[1024], response[1024];
	
    if(argin->length()<3) {
      Tango::Except::throw_exception(
				     (const char *)"Modbus::error_write",
				     (const char *)"At least 3 input arguments expected.",
				     (const char *)"Modbus::preset_multiple_registers");	
    }
	
    register_address = (*argin)[0];
    no_registers = (*argin)[1];
	
    check_argin(argin,2+no_registers,"Modbus::preset_multiple_registers");

    query[0] = PRESET_MULTIPLE_REGISTERS;
    query[1] = register_address >> 8;
    query[2] = register_address & 0xff;
    query[3] = no_registers >> 8;
    query[4] = no_registers & 0xff;
    query[5] = no_registers * 2;
    no_bytes = 6;
    for (int i=0; i<no_registers; i++)
      {
	query[6+(i*2)]   = ((*argin)[2+i]) >> 8;
	no_bytes++;
	query[6+(i*2)+1] = ((*argin)[2+i]) & 0xff;
	no_bytes++;
      }

    if(modbusCore->SendGet(query,no_bytes,response,5,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::preset_multiple_registers");
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_multiple_registers
}
//--------------------------------------------------------
/**
 *	Command MaskWriteRegister related method
 *	Description: Mask write a 16bits register.
 *
 *	@param argin register address, AND mask, OR mask
 */
//--------------------------------------------------------
void Modbus::mask_write_register(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::MaskWriteRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::mask_write_register) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short register_address, and_mask, or_mask;
    unsigned char query[1024], response[1024];
	
    check_argin(argin,3,"Modbus::mask_write_register");
    register_address = (*argin)[0];
    and_mask = (*argin)[1];
    or_mask = (*argin)[2];

    query[0] = MASK_WRITE_REGISTER;
    query[1] = (*argin)[0] >> 8;
    query[2] = (*argin)[0] & 0xff;
    query[3] = (*argin)[1] >> 8;
    query[4] = (*argin)[1] & 0xff;
    query[5] = (*argin)[2] >> 8;
    query[6] = (*argin)[2] & 0xff;

    if(modbusCore->SendGet(query,7,response,6,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::mask_write_register");
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::mask_write_register
}
//--------------------------------------------------------
/**
 *	Command ReadWriteRegister related method
 *	Description: Read and Write multiple 16bits registers.
 *               argin[0] = read address
 *               argin[1] = nb of registers to read
 *               argin[2] = write address,
 *               argin[3] = nb of registers to write,
 *               argin[4] = 1st register value to write
 *               argin[5] = 2nd register value to write
 *               ...
 *
 *	@param argin read address, no. to read, write address, nb.of write, write data
 *	@returns read registers
 */
//--------------------------------------------------------
Tango::DevVarShortArray *Modbus::read_write_register(const Tango::DevVarShortArray *argin)
{
	Tango::DevVarShortArray *argout;
	DEBUG_STREAM << "Modbus::ReadWriteRegister()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::read_write_register) ENABLED START -----*/
	
	//	Add your own code
	//	POGO has generated a method core with argout allocation.
    //	If you would like to use a static reference without copying,
    //	See "TANGO Device Server Programmer's Manual"
    //		(chapter : Writing a TANGO DS / Exchanging data)
    //------------------------------------------------------------
    argout  = new Tango::DevVarShortArray();
    long error;
    short no_bytes, no_read_registers, no_write_registers;
    unsigned char query[1024], response[1024];
	
    if(argin->length()<5) {
      Tango::Except::throw_exception(
				     (const char *)"Modbus::error_write",
				     (const char *)"At least 5 input arguments expected.",
				     (const char *)"Modbus::read_write_register");	
    }
	
    no_read_registers = (*argin)[1];
    no_write_registers = (*argin)[3];
    no_bytes = 0;
    check_argin(argin,4+no_write_registers,"Modbus::read_write_register");
	
    query[no_bytes++] = READ_WRITE_REGISTERS;
    query[no_bytes++] = (*argin)[0] >> 8;           // Read address MSB
    query[no_bytes++] = (*argin)[0] & 0xff;         // Read address LSB 
    query[no_bytes++] = no_read_registers >> 8;     // Word count for read MSB
    query[no_bytes++] = no_read_registers & 0xff;   // Word count for read LSB
    query[no_bytes++] = (*argin)[2] >> 8;           // Write address MSB
    query[no_bytes++] = (*argin)[2] & 0xff;         // Write address LSB 
    query[no_bytes++] = no_write_registers >> 8;    // Word count for write MSB
    query[no_bytes++] = no_write_registers & 0xff;  // Word count for write LSB
    query[no_bytes++] = no_write_registers*2;       // Byte count
    for (int i=0; i<no_write_registers; i++)
      {
	query[no_bytes++] = (*argin)[i+4] >> 8;
	query[no_bytes++] = (*argin)[i+4] & 0xff;
      }

    if(modbusCore->SendGet(query,no_bytes,response,2+no_read_registers*2,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::read_write_register");
      }
	
    if(no_read_registers != (short)(response[1]/2)) {
      char tmp[128];
      sprintf(tmp,"Wrong number of read registers. Got %d regs instead of %d",
	      (int)(response[1]/2) , (int)(no_read_registers));
      Tango::Except::throw_exception(
				     (const char *)"Modbus::error_read",
				     (const char *)tmp,
				     (const char *)"Modbus::read_write_register");	
    }
		
    argout->length(no_read_registers);
    for (int i=0; i<no_read_registers; i++)
      {
	(*argout)[i] = (response[i*2+2] << 8) + response[i*2+3];
      }

	/*----- PROTECTED REGION END -----*/	//	Modbus::read_write_register
	return argout;
}
//--------------------------------------------------------
/**
 *	Command PresetSingleRegisterBroadcast related method
 *	Description: Write single 16bits register at address 0 (Address reserved for broadcast)
 *               Does not wait for the equipment response.
 *
 *	@param argin register value.
 */
//--------------------------------------------------------
void Modbus::preset_single_register_broadcast(const Tango::DevVarShortArray *argin)
{
	DEBUG_STREAM << "Modbus::PresetSingleRegisterBroadcast()  - " << device_name << endl;
	/*----- PROTECTED REGION ID(Modbus::preset_single_register_broadcast) ENABLED START -----*/
	
	//	Add your own code
	long error;
    short register_address, value;
    unsigned char query[5], response[1024];
	
    check_argin(argin,2,"Modbus::preset_single_register_broadcast");
    register_address = (*argin)[0];
    value = (*argin)[1];
	
    query[0] = PRESET_SINGLE_REGISTER;
    query[1] = register_address >> 8;
    query[2] = register_address & 0xff;
    query[3] = value >> 8;
    query[4] = value & 0xff;

    if(modbusCore->Send(query,5,&error) != OK)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)modbusCore->GetErrorMessage(error),
				       (const char *)"Modbus::preset_single_register_broadcast");
      }
	
	/*----- PROTECTED REGION END -----*/	//	Modbus::preset_single_register_broadcast
}

/*----- PROTECTED REGION ID(Modbus::namespace_ending) ENABLED START -----*/

//	Additional Methods
//------------------------------------------------------------
  // method: get_protocol_number
  //
  // Descr: Return the protocol id according to the resource string.
  //------------------------------------------------------------
  int Modbus::get_protocol_number() {

#ifdef WIN32
	if (_stricmp(protocol.c_str(),"rtu")   == 0)
      return MBUS_RTU;

    if (_stricmp(protocol.c_str(),"ascii") == 0)
      return MBUS_ASCII;

    if (_stricmp(protocol.c_str(),"tcp")   == 0)
      return MBUS_TCP;
#else
	if (strcasecmp(protocol.c_str(),"rtu")   == 0)
      return MBUS_RTU;

    if (strcasecmp(protocol.c_str(),"ascii") == 0)
      return MBUS_ASCII;

    if (strcasecmp(protocol.c_str(),"tcp")   == 0)
      return MBUS_TCP;
#endif
	return NOTOK;
  }
//------------------------------------------------------------
  // Check if argin has the expected length and throw DevFailed 
  // in case of error.
  //------------------------------------------------------------
  void Modbus::check_argin(const Tango::DevVarShortArray *argin,int lgth,const char *where) {

    char tmp[256];
    sprintf(tmp,"Incorrect number of input arguments (%d expected)",lgth);
  
    if (argin->length() != (unsigned int)lgth)
      {
	Tango::Except::throw_exception(
				       (const char *)"Modbus::error_write",
				       (const char *)tmp,
				       (const char *)where);		  
      }

  }
//+------------------------------------------------------------------
/**
 *	method:	Modbus::data_in_cache
 *
 *	description:	Check if the command result is in the data cache
 *	
 *	cmd = command name
 *	adr = address to be read
 *	nb_reg = data number to be read
 *
 *  Returns -1 is data not in cache. Otherwise, returns the index
 * in the vector describing cached data of the block containing
 * the required data
 */
//+------------------------------------------------------------------
int Modbus::data_in_cache(const char *cmd,short adr,short nb_reg)
{
	unsigned long nb_block = cacheDef.size();
	int ret = -1;

	for (unsigned long loop = 0;loop < nb_block;loop++)
	{
		if (cacheDef[loop].cmd_name != cmd)
			continue;
		else
		{
			if ((adr >= cacheDef[loop].in_args[0]) &&
				(adr < (cacheDef[loop].in_args[0] + cacheDef[loop].in_args[1])))
			{
				if ((adr + nb_reg) <= (cacheDef[loop].in_args[0] + cacheDef[loop].in_args[1]))
				{
					ret = loop;
					break;
				}
			}
			else
				continue;
		}
	}

//
// Check that the thread is started
//	

	if (ret != -1)
	{
		unsigned int th_sec;
		{
			omni_mutex_lock sync(*(cacheDef[ret].data_block_mutex));
			th_sec = cacheDef[ret].nb_sec;
		}
	
		if (th_sec == 0)
			ret = -1;
	}
	
	return ret;
}


/*----- PROTECTED REGION END -----*/	//	Modbus::namespace_ending
} //	namespace
